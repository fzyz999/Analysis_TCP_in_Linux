\chapter{网络子系统相关核心数据结构}
\minitoc
    \section{网络子系统数据结构架构}    
%----------------------------------------------------------------------------------------
%                   Structure about Sock
%----------------------------------------------------------------------------------------
    \section{sock底层数据结构}  
        \subsection{sock\_common}

\begin{minted}[linenos]{C}
/*
Location:

    include/net/sock.h

Description:

    minimal network layer representation of sockets
    This is the minimal network layer representation of sockets, the header
    for struct sock and struct inet_timewait_sock.
Member:

 *  @skc_daddr: Foreign IPv4 addr
 *  @skc_rcv_saddr: Bound local IPv4 addr
 *  @skc_hash: hash value used with various protocol lookup tables
 *  @skc_u16hashes: two u16 hash values used by UDP lookup tables
 *  @skc_dport: placeholder for inet_dport/tw_dport
 *  @skc_num: placeholder for inet_num/tw_num
 *  @skc_family: network address family
 *  @skc_state: Connection state
 *  @skc_reuse: %SO_REUSEADDR setting
 *  @skc_reuseport: %SO_REUSEPORT setting
 *  @skc_bound_dev_if: bound device index if != 0
 *  @skc_bind_node: bind hash linkage for various protocol lookup tables
 *  @skc_portaddr_node: second hash linkage for UDP/UDP-Lite protocol
 *  @skc_prot: protocol handlers inside a network family
 *  @skc_net: reference to the network namespace of this socket
 *  @skc_node: main hash linkage for various protocol lookup tables
 *  @skc_nulls_node: main hash linkage for TCP/UDP/UDP-Lite protocol
 *  @skc_tx_queue_mapping: tx queue number for this connection
 *  @skc_flags: place holder for sk_flags
 *      %SO_LINGER (l_onoff), %SO_BROADCAST, %SO_KEEPALIVE,
 *      %SO_OOBINLINE settings, %SO_TIMESTAMPING settings
 *  @skc_incoming_cpu: record/match cpu processing incoming packets
 *  @skc_refcnt: reference count
*/
struct sock_common {
    /* skc_daddr and skc_rcv_saddr must be grouped on a 8 bytes aligned
     * address on 64bit arches : cf INET_MATCH()
     */
    union {
        __addrpair  skc_addrpair;
        struct {
            __be32  skc_daddr;
            __be32  skc_rcv_saddr;
        };
    };
    union  {
        unsigned int    skc_hash;
        __u16       skc_u16hashes[2];
    };
    /* skc_dport && skc_num must be grouped as well */
    union {
        __portpair  skc_portpair;
        struct {
            __be16  skc_dport;
            __u16   skc_num;
        };
    };

    unsigned short      skc_family;
    volatile unsigned char  skc_state;
    unsigned char       skc_reuse:4;
    unsigned char       skc_reuseport:1;
    unsigned char       skc_ipv6only:1;
    unsigned char       skc_net_refcnt:1;
    int         skc_bound_dev_if;
    union {
        struct hlist_node   skc_bind_node;
        struct hlist_nulls_node skc_portaddr_node;
    };
    struct proto        *skc_prot;
    possible_net_t      skc_net;

#if IS_ENABLED(CONFIG_IPV6)
    struct in6_addr     skc_v6_daddr;
    struct in6_addr     skc_v6_rcv_saddr;
#endif

    atomic64_t      skc_cookie;

    /* following fields are padding to force
     * offset(struct sock, sk_refcnt) == 128 on 64bit arches
     * assuming IPV6 is enabled. We use this padding differently
     * for different kind of 'sockets'
     */
    union {
        unsigned long   skc_flags;
        struct sock *skc_listener; /* request_sock */
        struct inet_timewait_death_row *skc_tw_dr; /* inet_timewait_sock */
    };
    /*
     * fields between dontcopy_begin/dontcopy_end
     * are not copied in sock_copy()
     */
    /* private: */
    int         skc_dontcopy_begin[0];
    /* public: */
    union {
        struct hlist_node   skc_node;
        struct hlist_nulls_node skc_nulls_node;
    };
    int         skc_tx_queue_mapping;
    union {
        int     skc_incoming_cpu;
        u32     skc_rcv_wnd;
        u32     skc_tw_rcv_nxt; /* struct tcp_timewait_sock  */
    };

    atomic_t        skc_refcnt;
    /* private: */
    int                     skc_dontcopy_end[0];
    union {
        u32     skc_rxhash;
        u32     skc_window_clamp;
        u32     skc_tw_snd_nxt; /* struct tcp_timewait_sock */
    };
    /* public: */
};
\end{minted}
        \subsection{sock}
\begin{minted}[linenos]{C}
/*
Location:

    include/net/sock.h

Description:

    sock结构是比较通用的网络层描述块，构成传输控制块的基础，与具体的协议族无关。
    它描述了各协议族的公共信息，因此不能直接作为传输层控制块来使用。不同协议族的
    传输层在使用该结构的时候都会对其进行拓展，来适合各自的传输特性。例如，inet_sock
    结构由sock结构及其它特性组成，构成了IPV4协议族传输控制块的基础。

Member:
  * struct sock - network layer representation of sockets
  * @__sk_common: shared layout with inet_timewait_sock
  * @sk_shutdown: SEND_SHUTDOWN 或者 RCV_SHUTDOWN的掩码
  * @sk_userlocks: %SO_SNDBUF and %SO_RCVBUF settings
  * @sk_lock:   synchronizer
  * @sk_rcvbuf: 接受缓冲区的大小（单位为字节）
  * @sk_wq: sock wait queue and async head
  * @sk_rx_dst: receive input route used by early demux
  * @sk_dst_cache: destination cache
  * @sk_policy: flow policy
  * @sk_receive_queue: incoming packets
  * @sk_wmem_alloc: transmit queue bytes committed
  * @sk_write_queue: Packet sending queue
  * @sk_omem_alloc: "o" is "option" or "other"
  * @sk_wmem_queued: persistent queue size
  * @sk_forward_alloc: space allocated forward
  * @sk_napi_id: id of the last napi context to receive data for sk
  * @sk_ll_usec: usecs to busypoll when there is no data
  * @sk_allocation: allocation mode
  * @sk_pacing_rate: Pacing rate (if supported by transport/packet scheduler)
  * @sk_max_pacing_rate: Maximum pacing rate (%SO_MAX_PACING_RATE)
  * @sk_sndbuf: size of send buffer in bytes
  * @sk_no_check_tx: %SO_NO_CHECK setting, set checksum in TX packets
  * @sk_no_check_rx: allow zero checksum in RX packets
  * @sk_route_caps: route capabilities (e.g. %NETIF_F_TSO)
  * @sk_route_nocaps: forbidden route capabilities (e.g NETIF_F_GSO_MASK)
  * @sk_gso_type: GSO type (e.g. %SKB_GSO_TCPV4)
  * @sk_gso_max_size: Maximum GSO segment size to build
  * @sk_gso_max_segs: Maximum number of GSO segments
  * @sk_lingertime: %SO_LINGER l_linger setting
  * @sk_backlog: always used with the per-socket spinlock held
  * @sk_callback_lock: used with the callbacks in the end of this struct
  * @sk_error_queue: rarely used
  * @sk_prot_creator: sk_prot of original sock creator (see ipv6_setsockopt,
  *           IPV6_ADDRFORM for instance)
  * @sk_err: last error
  * @sk_err_soft: errors that don't cause failure but are the cause of a
  *           persistent failure not just 'timed out'
  * @sk_drops: raw/udp drops counter
  * @sk_ack_backlog: current listen backlog
  * @sk_max_ack_backlog: listen backlog set in listen()
  * @sk_priority: %SO_PRIORITY setting
  * @sk_cgrp_prioidx: socket group's priority map index
  * @sk_type: socket type (%SOCK_STREAM, etc)
  * @sk_protocol: which protocol this socket belongs in this network family
  * @sk_peer_pid: &struct pid for this socket's peer
  * @sk_peer_cred: %SO_PEERCRED setting
  * @sk_rcvlowat: %SO_RCVLOWAT setting
  * @sk_rcvtimeo: %SO_RCVTIMEO setting
  * @sk_sndtimeo: %SO_SNDTIMEO setting
  * @sk_txhash: computed flow hash for use on transmit
  * @sk_filter: socket filtering instructions
  * @sk_timer: sock cleanup timer
  * @sk_stamp: time stamp of last packet received
  * @sk_tsflags: SO_TIMESTAMPING socket options
  * @sk_tskey: counter to disambiguate concurrent tstamp requests
  * @sk_socket: Identd and reporting IO signals
  * @sk_user_data: RPC layer private data
  * @sk_frag: cached page frag
  * @sk_peek_off: current peek_offset value
  * @sk_send_head: 发送队列的头指针
  * @sk_security: used by security modules
  * @sk_mark: generic packet mark
  * @sk_classid: this socket's cgroup classid
  * @sk_cgrp: this socket's cgroup-specific proto data
  * @sk_write_pending: a write to stream socket waits to start
  * @sk_state_change: callback to indicate change in the state of the sock
  * @sk_data_ready: callback to indicate there is data to be processed
  * @sk_write_space: callback to indicate there is bf sending space available
  * @sk_error_report: callback to indicate errors (e.g. %MSG_ERRQUEUE)
  * @sk_backlog_rcv: callback to process the backlog
  * @sk_destruct: called at sock freeing time, i.e. when all refcnt == 0
 */
struct sock {
    /*
     * Now struct inet_timewait_sock also uses sock_common, so please just
     * don't add nothing before this first member (__sk_common) --acme
     */
    struct sock_common  __sk_common;
#define sk_node         __sk_common.skc_node
#define sk_nulls_node       __sk_common.skc_nulls_node
#define sk_refcnt       __sk_common.skc_refcnt
#define sk_tx_queue_mapping __sk_common.skc_tx_queue_mapping

#define sk_dontcopy_begin   __sk_common.skc_dontcopy_begin
#define sk_dontcopy_end     __sk_common.skc_dontcopy_end
#define sk_hash         __sk_common.skc_hash
#define sk_portpair     __sk_common.skc_portpair
#define sk_num          __sk_common.skc_num
#define sk_dport        __sk_common.skc_dport
#define sk_addrpair     __sk_common.skc_addrpair
#define sk_daddr        __sk_common.skc_daddr
#define sk_rcv_saddr        __sk_common.skc_rcv_saddr
#define sk_family       __sk_common.skc_family
#define sk_state        __sk_common.skc_state
#define sk_reuse        __sk_common.skc_reuse
#define sk_reuseport        __sk_common.skc_reuseport
#define sk_ipv6only     __sk_common.skc_ipv6only
#define sk_net_refcnt       __sk_common.skc_net_refcnt
#define sk_bound_dev_if     __sk_common.skc_bound_dev_if
#define sk_bind_node        __sk_common.skc_bind_node
#define sk_prot         __sk_common.skc_prot
#define sk_net          __sk_common.skc_net
#define sk_v6_daddr     __sk_common.skc_v6_daddr
#define sk_v6_rcv_saddr __sk_common.skc_v6_rcv_saddr
#define sk_cookie       __sk_common.skc_cookie
#define sk_incoming_cpu     __sk_common.skc_incoming_cpu
#define sk_flags        __sk_common.skc_flags
#define sk_rxhash       __sk_common.skc_rxhash

    socket_lock_t       sk_lock;
    struct sk_buff_head sk_receive_queue;
    /*
     * The backlog queue is special, it is always used with
     * the per-socket spinlock held and requires low latency
     * access. Therefore we special case it's implementation.
     * Note : rmem_alloc is in this structure to fill a hole
     * on 64bit arches, not because its logically part of
     * backlog.
     */
    struct {
        atomic_t    rmem_alloc;
        int     len;
        struct sk_buff  *head;
        struct sk_buff  *tail;
    } sk_backlog;
#define sk_rmem_alloc sk_backlog.rmem_alloc
    int         sk_forward_alloc;

    __u32           sk_txhash;
#ifdef CONFIG_NET_RX_BUSY_POLL
    unsigned int        sk_napi_id;
    unsigned int        sk_ll_usec;
#endif
    atomic_t        sk_drops;
    int         sk_rcvbuf;

    struct sk_filter __rcu  *sk_filter;
    union {
        struct socket_wq __rcu  *sk_wq;
        struct socket_wq    *sk_wq_raw;
    };
#ifdef CONFIG_XFRM
    struct xfrm_policy __rcu *sk_policy[2];
#endif
    struct dst_entry    *sk_rx_dst;
    struct dst_entry __rcu  *sk_dst_cache;
    /* Note: 32bit hole on 64bit arches */
    atomic_t        sk_wmem_alloc;
    atomic_t        sk_omem_alloc;
    int         sk_sndbuf;
    struct sk_buff_head sk_write_queue;
    kmemcheck_bitfield_begin(flags);
    unsigned int        sk_shutdown  : 2,
                sk_no_check_tx : 1,
                sk_no_check_rx : 1,
                sk_userlocks : 4,
                sk_protocol  : 8,
                sk_type      : 16;
#define SK_PROTOCOL_MAX U8_MAX
    kmemcheck_bitfield_end(flags);
    int         sk_wmem_queued;
    gfp_t           sk_allocation;
    u32         sk_pacing_rate; /* bytes per second */
    u32         sk_max_pacing_rate;
    netdev_features_t   sk_route_caps;
    netdev_features_t   sk_route_nocaps;
    int         sk_gso_type;
    unsigned int        sk_gso_max_size;
    u16         sk_gso_max_segs;
    int         sk_rcvlowat;
    unsigned long           sk_lingertime;
    struct sk_buff_head sk_error_queue;
    struct proto        *sk_prot_creator;
    rwlock_t        sk_callback_lock;
    int         sk_err,
                sk_err_soft;
    u32         sk_ack_backlog;
    u32         sk_max_ack_backlog;
    __u32           sk_priority;
#if IS_ENABLED(CONFIG_CGROUP_NET_PRIO)
    __u32           sk_cgrp_prioidx;
#endif
    struct pid      *sk_peer_pid;
    const struct cred   *sk_peer_cred;
    long            sk_rcvtimeo;
    long            sk_sndtimeo;
    struct timer_list   sk_timer;
    ktime_t         sk_stamp;
    u16         sk_tsflags;
    u32         sk_tskey;
    struct socket       *sk_socket;
    void            *sk_user_data;
    struct page_frag    sk_frag;
    struct sk_buff      *sk_send_head;
    __s32           sk_peek_off;
    int         sk_write_pending;
#ifdef CONFIG_SECURITY
    void            *sk_security;
#endif
    __u32           sk_mark;
#ifdef CONFIG_CGROUP_NET_CLASSID
    u32         sk_classid;
#endif
    struct cg_proto     *sk_cgrp;
    void            (*sk_state_change)(struct sock *sk);
    void            (*sk_data_ready)(struct sock *sk);
    void            (*sk_write_space)(struct sock *sk);
    void            (*sk_error_report)(struct sock *sk);
    int         (*sk_backlog_rcv)(struct sock *sk,
                          struct sk_buff *skb);
    void                    (*sk_destruct)(struct sock *sk);
};
\end{minted}
    \subsection{\mintinline{C}{request_sock}}

\begin{minted}[linenos]{C}
/* 
Location:

    /include/net/request_sock.h

Description:
    
    struct request_sock - mini sock to represent a connection request
    该结构用于表示一个简单的TCP连接请求。
*/
struct request_sock {
    struct sock_common      __req_common;
#define rsk_refcnt          __req_common.skc_refcnt
#define rsk_hash            __req_common.skc_hash
#define rsk_listener            __req_common.skc_listener
#define rsk_window_clamp        __req_common.skc_window_clamp
#define rsk_rcv_wnd         __req_common.skc_rcv_wnd

    struct request_sock     *dl_next;
    u16             mss;
    u8              num_retrans; /* number of retransmits */
    u8              cookie_ts:1; /* syncookie: encode tcpopts in timestamp */
    u8              num_timeout:7; /* number of timeouts */
    u32             ts_recent;
    struct timer_list       rsk_timer;
    const struct request_sock_ops   *rsk_ops;
    struct sock         *sk;
    u32             *saved_syn;
    u32             secid;
    u32             peer_secid;
};
\end{minted}

    \subsection{sk\_buff}
\label{sec:sk_buff}

\mintinline{c}{struct sk_buff}这一结构体在各层协议中都会被用到。该结构体存储了
网络数据报的所有信息。包括各层的头部以及payload，以及必要的各层实现相关的信息。

该结构体的定义较长，需要一点一点分析。结构体的开头为
\begin{minted}[linenos]{c}
  union {
    struct {
      /* These two members must be first. */
      struct sk_buff          *next;
      struct sk_buff          *prev;

      union {
        ktime_t         tstamp;
        struct skb_mstamp skb_mstamp;
      };
    };
    struct rb_node  rbnode; /* used in netem and tcp stack */
  };
\end{minted}

可以看到，\mintinline{c}{sk_buff}可以被组织成两种数据结构：
双向链表和红黑树。且一个\mintinline{c}{sk_buff}不是在双向链表中，就是在
红黑树中，因此，采用了union来节约空间。next和prev两个域是用于双向链表的结构体，
而rbnode是红黑树相关的结构。

包的到达/发送时间存放在\mintinline{c}{union {ktime_t tstamp;struct skb_mstamp skb_mstamp;};}中，
之所以这里有两种不同的时间戳类型，是因为有时候调用\mintinline{c}{ktime_get()}的
成本太高。因此，内核开发者希望能够在TCP协议栈中实现一个轻量级的微秒级的时间戳。
\mintinline{c}{struct skb_mstamp}正是结合了\mintinline{c}{local_clock()}和
\mintinline{c}{jiffies}二者，而实现的一个轻量级的工具。当然，根据内核邮件列表中
的说法，并不是任何时候都可以用该工具替换调\mintinline{c}{ktime_get()}的。
因此，在\mintinline{c}{struct sk_buff}结构体中，采用\mintinline{c}{union}的方式
同时保留了这二者。

在定义完数据结构相关的一些部分后，又定义了如下的结构体
\begin{minted}[linenos]{c}
  /* 拥有该sk_buff的套接字的指针 */
  struct sock             *sk;
  /* 与该包关联的网络设备 */
  struct net_device       *dev;
  /* 控制用的缓冲区，用于存放各层的私有数据 */
  char                    cb[48] __aligned(8);
  /* 存放了目的地项的引用计数 */
  unsigned long           _skb_refdst;
  /* 析构函数 */
  void                    (*destructor)(struct sk_buff *skb);
#ifdef CONFIG_XFRM
  /* xfrm加密通道 */
  struct  sec_path        *sp;
#endif
#if IS_ENABLED(CONFIG_BRIDGE_NETFILTER)
  /* 保存和bridge相关的信息 */
  struct nf_bridge_info   *nf_bridge;
#endif
\end{minted}

其中的\mintinline{c}{char cb[48]}比较有意思，各层都使用这个buffer来存放自己
私有的变量。这里值得注意的是，如果想要跨层传递数据，则需要使用
\mintinline{c}{skb_clone()}。XFRM则是Linux在2.6版本中引入的一个安全方面的扩展。

之后，又定义了一些长度相关的字段。\mintinline{c}{len}代表buffer中的数据报总长度（含
各协议的头部），以及分片长度。而\mintinline{c}{data_len}代表分片中的数据的长度。
\mintinline{c}{mac_len}是MAC层头部的长度。\mintinline{c}{hdr_len}是一个
克隆出来的可写的头部的长度。
\begin{minted}[linenos]{c}
unsigned int            len,
                        data_len;
__u16                   mac_len,
                        hdr_len;
\end{minted}

kmemcheck是内核中的一套内存检测工具。kmemcheck\_bitfield\_begin
和kmemcheck\_bitfield\_end可以用于说明一段内容的起始和终止位置。
其代码定义如下：
\begin{minted}[linenos]{c}
#define kmemcheck_bitfield_begin(name)  \
        int name##_begin[0];

#define kmemcheck_bitfield_end(name)    \
        int name##_end[0];
\end{minted}

通过定义，我们不难看出，这两个宏是用于在代码中产生两个对应于位域的起始地址和终止地址的
符号的。当然，这两个宏是为kmemcheck的功能服务的。如果没有开启该功能的话，这两个宏的
定义为空，也即不会产生任何作用。
\begin{minted}[linenos]{c}
/* Following fields are _not_ copied in __copy_skb_header()
* Note that queue_mapping is here mostly to fill a hole.
*/
kmemcheck_bitfield_begin(flags1);
__u16       queue_mapping;      /* 对于多队列设备的队列关系映射                 */
__u8        cloned:1,           /* 是否被克隆                               */
            nohdr:1,            /* 只引用了负载                                 */
            fclone:2,           /* skbuff克隆的情况                             */
            peeked:1,           /* peeked表明该包已经被统计过了，无需再次统计 */
            head_frag:1,
            xmit_more:1;        /* 在队列中有更多的SKB在等待                    */
/* one bit hole */
kmemcheck_bitfield_end(flags1);
\end{minted}

在这段定义中，内核将一系列的标志位命名为了flags1，利用那两个函数可以在生成的代码中插入
\mintinline{c}{flags1_begin}和\mintinline{c}{flags1_end}两个符号。这样，当有需要
的时候，可以通过这两个符号找到这一段的起始地址和结束地址。

紧接着是一个包的头部，这一部分再次使用了类似上面的方法，用了两个零长度的数组
\mintinline{c}{headers_start}和\mintinline{c}{headers_end}来标明头部的起始
和终止地址。
\begin{minted}[linenos]{c}
        /* 在__copy_skb_header()中，只需使用一个memcpy()即可将headers_start/end
         * 之间的部分克隆一份。
         */
        /* private: */
        __u32                   headers_start[0];
        /* public: */

/* if you move pkt_type around you also must adapt those constants */
#ifdef __BIG_ENDIAN_BITFIELD
#define PKT_TYPE_MAX    (7 << 5)
#else
#define PKT_TYPE_MAX    7
#endif
#define PKT_TYPE_OFFSET()       offsetof(struct sk_buff, __pkt_type_offset)

        __u8                    __pkt_type_offset[0];
        /* 该包的类型 */
        __u8                    pkt_type:3;
        __u8                    pfmemalloc:1;
        /* 是否允许本地分片(local fragmentation) */
        __u8                    ignore_df:1; 
        /* 表明该skb和连接的关系 */
        __u8                    nfctinfo:3;
        /* netfilter包追踪标记 */
        __u8                    nf_trace:1;
        /* 驱动（硬件）给出来的checksum */
        __u8                    ip_summed:2;
        /* 允许该socket到队列的对应关系发生变更 */
        __u8                    ooo_okay:1;
        /* 表明哈希值字段hash是一个典型的4元组的通过传输端口的哈希 */
        __u8                    l4_hash:1;
        /* 表明哈希值字段hash是通过软件栈计算出来的 */
        __u8                    sw_hash:1;
        /* 表明wifi_acked是否被设置了 */
        __u8                    wifi_acked_valid:1;
        /* 表明帧是否在wifi上被确认了 */
        __u8                    wifi_acked:1;
        
        /* 请求NIC将最后的4个字节作为以太网FCS来对待 */
        __u8                    no_fcs:1;
        /* Indicates the inner headers are valid in the skbuff. */
        __u8                    encapsulation:1;
        __u8                    encap_hdr_csum:1;
        __u8                    csum_valid:1;
        __u8                    csum_complete_sw:1;
        __u8                    csum_level:2;
        __u8                    csum_bad:1;

#ifdef CONFIG_IPV6_NDISC_NODETYPE
        __u8                    ndisc_nodetype:2; /* 路由类型（来自链路层） */
#endif
        /* 标明该skbuff是否被ipvs拥有 */
        __u8                    ipvs_property:1;
        __u8                    inner_protocol_type:1;
        __u8                    remcsum_offload:1;
        /* 3 or 5 bit hole */

#ifdef CONFIG_NET_SCHED
        __u16                   tc_index;       /* traffic control index */
#ifdef CONFIG_NET_CLS_ACT
        __u16                   tc_verd;        /* traffic control verdict */
#endif
#endif

        union {
                __wsum          csum; /* 校验码 */
                struct {
                        /* 从skb->head开始到应当计算校验码的起始位置的偏移 */
                        __u16   csum_start; 
                        /* 从csum_start开始到存储校验码的位置的偏移 */
                        __u16   csum_offset;
                };
        };
        __u32                   priority; /* 包队列的优先级 */
        int                     skb_iif; /* 到达的设备的序号 */
        __u32                   hash; /* 包的哈希值 */
        __be16                  vlan_proto; /* vlan包装协议 */
        __u16                   vlan_tci; /* vlan tag控制信息 */
#if defined(CONFIG_NET_RX_BUSY_POLL) || defined(CONFIG_XPS)
        union {
                unsigned int    napi_id; /* 表明该skb来源的NAPI结构体的id */
                unsigned int    sender_cpu;
        };
#endif
        union {
#ifdef CONFIG_NETWORK_SECMARK
                __u32           secmark; /* 安全标记 */
#endif
#ifdef CONFIG_NET_SWITCHDEV
                __u32           offload_fwd_mark; /* fwding offload mark */
#endif
        };

        union {
                __u32           mark; /* 通用的包的标记位 */
                __u32           reserved_tailroom;
        };

        union {
                __be16          inner_protocol; /* 协议（封装好的） */
                __u8            inner_ipproto;
        };

        /* 已封装的内部传输层头部 */
        __u16                   inner_transport_header; 
        /* 已封装的内部网络层头部 */
        __u16                   inner_network_header; 
        /* 已封装的内部链路层头部 */
        __u16                   inner_mac_header;

        /* 驱动（硬件）给出的包的协议类型 */
        __be16                  protocol;
        /* 传输层头部 */
        __u16                   transport_header;
        /* 网络层头部 */
        __u16                   network_header;
        /* 数据链路层头部 */
        __u16                   mac_header;

        /* private: */
        __u32                   headers_end[0];
\end{minted}

最后是一组是管理相关的字段。其中，\mintinline{c}{head}和\mintinline{c}{end}
代表被分配的内存的起始位置和终止位置。而\mintinline{c}{data}和\mintinline{c}{tail}
则是实际数据的起始和终止位置。
\begin{minted}[linenos]{c}
/* These elements must be at the end, see alloc_skb() for details.  */
        sk_buff_data_t          tail;
        sk_buff_data_t          end;
        unsigned char           *head,
                                *data;
        unsigned int            truesize;
        atomic_t                users;
\end{minted}
\mintinline{c}{users}是引用计数，所以是个原子的。\mintinline{c}{truesize}是
数据报的真实大小。

\subsection{msghdr}
\begin{minted}[linenos]{c}
/* Location: include/linux/socket.h */
struct msghdr {
        void            *msg_name;      /* 指向socket地址结构体的指针 */
        int             msg_namelen;    /* socket地址结构体的大小 */
        struct iov_iter msg_iter;       /* 数据 */
        void            *msg_control;   /* 辅助数据 */
        __kernel_size_t msg_controllen; /* 辅助数据缓冲区大小 */
        unsigned int    msg_flags;      /* 收到的消息所带的标记 */
        struct kiocb    *msg_iocb;      /* 指向iocb的指针（用于异步请求） */
};
\end{minted}

%----------------------------------------------------------------------------------------
%                   Structure about Inet
%----------------------------------------------------------------------------------------
    \section{inet层相关数据结构}
        \subsection{\mintinline{C}{ip_options}}

\begin{minted}[linenos]{C}


/*
Location:

Description:
    @faddr - Saved first hop address
    @nexthop - Saved nexthop address in LSRR and SSRR
    @is_strictroute - Strict source route
    @srr_is_hit - Packet destination addr was our one
    @is_changed - IP checksum more not valid
    @rr_needaddr - Need to record addr of outgoing dev
    @ts_needtime - Need to record timestamp
    @ts_needaddr - Need to record addr of outgoing dev
*/
struct ip_options {
    __be32      faddr;
    /*下一跳*/
    __be32      nexthop;
    /*标识IP首部中选项所占的字节数*/
    unsigned char   optlen;
    /*
        记录宽松路由或严格路由选项在IP首部中的偏移量，
        即选项的第一个字节的地址减去IP首部的第一个字节的地址
    */
    unsigned char   srr;
    unsigned char   rr;
    unsigned char   ts;
    unsigned char   is_strictroute:1,
            srr_is_hit:1,
            is_changed:1,
            rr_needaddr:1,
            ts_needtime:1,
            ts_needaddr:1;
    unsigned char   router_alert;
    unsigned char   cipso;
    unsigned char   __pad2;
    unsigned char   __data[0];
};
\end{minted}    
        \subsection{\mintinline{C}{inet_request_sock}}

        该结构位于\mintinline{C}{/include/net/inet_sock.h}中。

        这个结构的功能呢？

\begin{minted}[linenos]{C}
struct inet_request_sock {
    struct request_sock req;
#define ir_loc_addr     req.__req_common.skc_rcv_saddr
#define ir_rmt_addr     req.__req_common.skc_daddr
#define ir_num          req.__req_common.skc_num
#define ir_rmt_port     req.__req_common.skc_dport
#define ir_v6_rmt_addr      req.__req_common.skc_v6_daddr
#define ir_v6_loc_addr      req.__req_common.skc_v6_rcv_saddr
#define ir_iif          req.__req_common.skc_bound_dev_if
#define ir_cookie       req.__req_common.skc_cookie
#define ireq_net        req.__req_common.skc_net
#define ireq_state      req.__req_common.skc_state
#define ireq_family     req.__req_common.skc_family

    kmemcheck_bitfield_begin(flags);
    u16         snd_wscale : 4,
                rcv_wscale : 4,
                tstamp_ok  : 1,
                sack_ok    : 1,
                wscale_ok  : 1,
                ecn_ok     : 1,
                acked      : 1,
                no_srccheck: 1;
    kmemcheck_bitfield_end(flags);
    u32                     ir_mark;
    union {
        struct ip_options_rcu   *opt;
        struct sk_buff      *pktopts;
    };
};
\end{minted}     
        \subsection{\mintinline{C}{inet_connection_sock_af_ops}}

            该结构位于\mintinline{C}{/include/net/inet_connect_sock.h}中,其后面的af表示address of function即函数地址, ops表示operations，即操作。

            该结构封装了一组与传输层有关的操作集，包括向网络层发送的接口、传输层的\mintinline{C}{setsockopt}接口等。

\begin{minted}[linenos]{C}
struct inet_connection_sock_af_ops {
    int     (*queue_xmit)(struct sock *sk, struct sk_buff *skb, struct flowi *fl);
    void        (*send_check)(struct sock *sk, struct sk_buff *skb);
    int     (*rebuild_header)(struct sock *sk);
    void        (*sk_rx_dst_set)(struct sock *sk, const struct sk_buff *skb);
    int     (*conn_request)(struct sock *sk, struct sk_buff *skb);
    struct sock *(*syn_recv_sock)(const struct sock *sk, struct sk_buff *skb,
                      struct request_sock *req,
                      struct dst_entry *dst,
                      struct request_sock *req_unhash,
                      bool *own_req);
    u16     net_header_len;
    u16     net_frag_header_len;
    u16     sockaddr_len;
    int     (*setsockopt)(struct sock *sk, int level, int optname, 
                  char __user *optval, unsigned int optlen);
    int     (*getsockopt)(struct sock *sk, int level, int optname, 
                  char __user *optval, int __user *optlen);
#ifdef CONFIG_COMPAT
    int     (*compat_setsockopt)(struct sock *sk,
                int level, int optname,
                char __user *optval, unsigned int optlen);
    int     (*compat_getsockopt)(struct sock *sk,
                int level, int optname,
                char __user *optval, int __user *optlen);
#endif
    void        (*addr2sockaddr)(struct sock *sk, struct sockaddr *);
    int     (*bind_conflict)(const struct sock *sk,
                     const struct inet_bind_bucket *tb, bool relax);
    void        (*mtu_reduced)(struct sock *sk);
};
\end{minted}

        \subsection{\mintinline{C}{inet_connect_sock}}

            该结构位于\mintinline{C}{/include/net/inet_connect_sock.h}中，它是所有面向传输控制块的表示。其在\mintinline{C}{inet_sock}的基础上，增加了有关连接，确认，重传等成员。
            
\begin{minted}[linenos]{C}
/** inet_connection_sock - INET connection oriented sock
 *
 * @icsk_accept_queue:     FIFO of established children 
 * @icsk_bind_hash:    Bind node
 * @icsk_timeout:      Timeout
 * @icsk_retransmit_timer: Resend (no ack)
 * @icsk_rto:          Retransmit timeout
 * @icsk_pmtu_cookie       Last pmtu seen by socket
 * @icsk_ca_ops        Pluggable congestion control hook
 * @icsk_af_ops        Operations which are AF_INET{4,6} specific
 * @icsk_ca_state:     拥塞控制状态
 * @icsk_retransmits:      Number of unrecovered [RTO] timeouts
 * @icsk_pending:      Scheduled timer event
 * @icsk_backoff:      Backoff
 * @icsk_syn_retries:      Number of allowed SYN (or equivalent) retries
 * @icsk_probes_out:       unanswered 0 window probes
 * @icsk_ext_hdr_len:      Network protocol overhead (IP/IPv6 options)
 * @icsk_ack:          Delayed ACK control data
 * @icsk_mtup;         MTU probing control data
 */
struct inet_connection_sock {
    /* inet_sock has to be the first member! */
    struct inet_sock      icsk_inet;
    struct request_sock_queue icsk_accept_queue;
    struct inet_bind_bucket   *icsk_bind_hash;
    unsigned long         icsk_timeout;
    struct timer_list     icsk_retransmit_timer;
    struct timer_list     icsk_delack_timer;
    __u32             icsk_rto;
    __u32             icsk_pmtu_cookie;
    const struct tcp_congestion_ops *icsk_ca_ops;
    const struct inet_connection_sock_af_ops *icsk_af_ops;
    unsigned int          (*icsk_sync_mss)(struct sock *sk, u32 pmtu);
    __u8              icsk_ca_state:6,
                  icsk_ca_setsockopt:1,
                  icsk_ca_dst_locked:1;
    __u8              icsk_retransmits;
    __u8              icsk_pending;
    __u8              icsk_backoff;
    __u8              icsk_syn_retries;
    __u8              icsk_probes_out;
    __u16             icsk_ext_hdr_len;
    struct {
        __u8          pending;   /* ACK is pending             */
        __u8          quick;     /* Scheduled number of quick acks     */
        __u8          pingpong;  /* The session is interactive         */
        __u8          blocked;   /* Delayed ACK was blocked by socket lock */
        __u32         ato;       /* Predicted tick of soft clock       */
        unsigned long     timeout;   /* Currently scheduled timeout        */
        __u32         lrcvtime;  /* timestamp of last received data packet */
        __u16         last_seg_size; /* Size of last incoming segment      */
        __u16         rcv_mss;   /* MSS used for delayed ACK decisions     */ 
    } icsk_ack;
    struct {
        int       enabled;

        /* Range of MTUs to search */
        int       search_high;
        int       search_low;

        /* Information on the current probe. */
        int       probe_size;

        u32       probe_timestamp;
    } icsk_mtup;
    u32           icsk_user_timeout;

    u64           icsk_ca_priv[64 / sizeof(u64)]; /* 拥塞控制算法私有空间 */
#define ICSK_CA_PRIV_SIZE      (8 * sizeof(u64))
};
\end{minted}

	\subsection{\mintinline{c}{inet_timewait_sock}}
		\label{subsec:inet_timewait_sock}
			在进入到等待关闭的状态时，已经不需要完整的传输控制块了。Linux为了减轻在重负载情况下的
			内存消耗，定义了这个简化的结构体。
\begin{minted}[linenos]{c}
/* include/net/inet_timewait_sock.h
 *
 * 这个结构体的存在主要是为了解决重负载情况下的内存负担问题。
 */
struct inet_timewait_sock {
        /* 此处也使用了sock_common结构体。
         * Now struct sock also uses sock_common, so please just
         * don't add nothing before this first member (__tw_common) --acme
         */

        struct sock_common      __tw_common;
        /* 通过宏定义为sock_common中的结构体起一个tw开头的别名。 */
#define tw_family               __tw_common.skc_family
#define tw_state                __tw_common.skc_state
#define tw_reuse                __tw_common.skc_reuse
#define tw_ipv6only             __tw_common.skc_ipv6only
#define tw_bound_dev_if         __tw_common.skc_bound_dev_if
#define tw_node                 __tw_common.skc_nulls_node
#define tw_bind_node            __tw_common.skc_bind_node
#define tw_refcnt               __tw_common.skc_refcnt
#define tw_hash                 __tw_common.skc_hash
#define tw_prot                 __tw_common.skc_prot
#define tw_net                  __tw_common.skc_net
#define tw_daddr                __tw_common.skc_daddr
#define tw_v6_daddr             __tw_common.skc_v6_daddr
#define tw_rcv_saddr            __tw_common.skc_rcv_saddr
#define tw_v6_rcv_saddr         __tw_common.skc_v6_rcv_saddr
#define tw_dport                __tw_common.skc_dport
#define tw_num                  __tw_common.skc_num
#define tw_cookie               __tw_common.skc_cookie
#define tw_dr                   __tw_common.skc_tw_dr

        /* 超时时间 */
        int                     tw_timeout; 
        /* 子状态，用于区分FIN_WAIT2和TIMEWAIT */
        volatile unsigned char  tw_substate; 
        /* 窗口缩放 */
        unsigned char           tw_rcv_wscale;

        /* 下面的部分都和inet_sock中的成员相对应的。 */
        __be16                  tw_sport;
        kmemcheck_bitfield_begin(flags);
        /* And these are ours. */
        unsigned int            tw_kill         : 1,
                                tw_transparent  : 1,
                                tw_flowlabel    : 20,   
                                tw_pad          : 2,    /* 2 bits hole */
                                tw_tos          : 8;
        kmemcheck_bitfield_end(flags);
        /* 超时计时器 */
        struct timer_list       tw_timer;
        struct inet_bind_bucket *tw_tb;
};
\end{minted}

\subsection{\mintinline{C}{sockaddr & sockaddr_in}}
\label{subsec:sockaddr_and_sockaddr_in}
\mintinline{c}{sockaddr}用于描述一个地址。
\begin{minted}[linenos]{c}
/* include/linux/socket.h */
struct sockaddr {
        sa_family_t     sa_family;      /* 地址所属的协议族, AF_xxx       */
        char            sa_data[14];    /* 在协议下的地址 */
};
\end{minted}

可以看出\mintinline{c}{sockaddr}是一个较为通用的描述方法。可以支持任意的网络层协议。
那么具体到我们的情况，就是IP网络。下面是IP网络下，该结构体的定义。

\begin{minted}[linenos]{c}
/* include/uapi/linux/in.h
 * 该结构体用于描述一个Internet (IP) 套接字的地址 
 */
struct sockaddr_in {
  __kernel_sa_family_t  sin_family;     /* 这里和sockaddr是对应的，填写IP网络 */
  __be16                sin_port;       /* 端口号                           */
  struct in_addr        sin_addr;       /* Internet 地址                    */

  /* 填充位，为了将sockaddr_in填充到和sockaddr一样长 */
  unsigned char         __pad[__SOCK_SIZE__ - sizeof(short int) -
                        sizeof(unsigned short int) - sizeof(struct in_addr)];
};
\end{minted}

\mintinline{c}{sockaddr}的使用方法是在需要的地方直接强制转型成相应网络的结构体。
因此，需要让二者一样大。这就是为何\mintinline{c}{sockaddr_in}要加填充位的原因。

\subsection{ip\_options}
\label{subsec:ip_options}

\begin{minted}[linenos]{c}
/** struct ip_options - IP Options
 *
 * @faddr - 保存的第一跳地址
 * @nexthop - 保存在LSRR和SSRR的下一跳地址
 * @is_strictroute - 严格的源路由
 * @srr_is_hit - 包目标地址命中
 * @is_changed - IP校验和不合法
 * @rr_needaddr - 需要记录出口设备的地址
 * @ts_needtime - 需要记录时间戳
 * @ts_needaddr - 需要记录出口设备的地址
 */
struct ip_options {
        __be32          faddr;
        __be32          nexthop;
        unsigned char   optlen;
        unsigned char   srr;
        unsigned char   rr;
        unsigned char   ts;
        unsigned char   is_strictroute:1,
                        srr_is_hit:1,
                        is_changed:1,
                        rr_needaddr:1,
                        ts_needtime:1,
                        ts_needaddr:1;
        unsigned char   router_alert;
        unsigned char   cipso;
        unsigned char   __pad2;
        unsigned char   __data[0];
};

struct ip_options_rcu {
        struct rcu_head rcu;
        struct ip_options opt;
};
\end{minted}

%----------------------------------------------------------------------------------------
%                   Structre about Router
%----------------------------------------------------------------------------------------
    \section{路由相关数据结构}
                
        \subsection{\mintinline{C}{dst_entry}}

            该结构位于\mintinline{C}{/include/net/dst.h}中。
            
            最终生成的IP数据报的路由称为目的入口(\mintinline{C}{dst_entry})，目的入口反映了相邻的外部主机在本地主机内部的一种“映象”。它是与协议无关的目的路由缓存相关的数据结构，保护了路由缓存链接在一起的数据结构成员变量、垃圾回收相关的成员变量、邻居项相关的成员、二层缓存头相关的成员、输入/输出函数指针以用于命中路由缓存的数据包进行后续的数据处理等。

\begin{minted}[linenos]{C}
/* Each dst_entry has reference count and sits in some parent list(s).
 * When it is removed from parent list, it is "freed" (dst_free).
 * After this it enters dead state (dst->obsolete > 0) and if its refcnt
 * is zero, it can be destroyed immediately, otherwise it is added
 * to gc list and garbage collector periodically checks the refcnt.
 */
struct dst_entry {
    struct rcu_head     rcu_head;
    struct dst_entry    *child;
    struct net_device       *dev;
    struct  dst_ops         *ops;
    unsigned long       _metrics;
    unsigned long           expires;
    struct dst_entry    *path;
    struct dst_entry    *from;
#ifdef CONFIG_XFRM
    struct xfrm_state   *xfrm;
#else
    void            *__pad1;
#endif
    int         (*input)(struct sk_buff *);
    int         (*output)(struct net *net, struct sock *sk, struct sk_buff *skb);

    unsigned short      flags;
#define DST_HOST        0x0001
#define DST_NOXFRM      0x0002
#define DST_NOPOLICY        0x0004
#define DST_NOHASH      0x0008
#define DST_NOCACHE     0x0010
#define DST_NOCOUNT     0x0020
#define DST_FAKE_RTABLE     0x0040
#define DST_XFRM_TUNNEL     0x0080
#define DST_XFRM_QUEUE      0x0100
#define DST_METADATA        0x0200

    unsigned short      pending_confirm;

    short           error;

    /* A non-zero value of dst->obsolete forces by-hand validation
     * of the route entry.  Positive values are set by the generic
     * dst layer to indicate that the entry has been forcefully
     * destroyed.
     *
     * Negative values are used by the implementation layer code to
     * force invocation of the dst_ops->check() method.
     */
    short           obsolete;
#define DST_OBSOLETE_NONE   0
#define DST_OBSOLETE_DEAD   2
#define DST_OBSOLETE_FORCE_CHK  -1
#define DST_OBSOLETE_KILL   -2
    unsigned short      header_len; /* more space at head required */
    unsigned short      trailer_len;    /* space to reserve at tail */
#ifdef CONFIG_IP_ROUTE_CLASSID
    __u32           tclassid;
#else
    __u32           __pad2;
#endif

#ifdef CONFIG_64BIT
    struct lwtunnel_state   *lwtstate;
    /*
     * Align __refcnt to a 64 bytes alignment
     * (L1_CACHE_SIZE would be too much)
     */
    long            __pad_to_align_refcnt[1];
#endif
    /*
     * __refcnt wants to be on a different cache line from
     * input/output/ops or performance tanks badly
     */
    atomic_t        __refcnt;   /* client references    */
    int         __use;
    unsigned long       lastuse;
#ifndef CONFIG_64BIT
    struct lwtunnel_state   *lwtstate;
#endif
    union {
        struct dst_entry    *next;
        struct rtable __rcu *rt_next;
        struct rt6_info     *rt6_next;
        struct dn_route __rcu   *dn_next;
    };
};
\end{minted}

        \subsection{\mintinline{C}{rtable}}

            该结构位于\mintinline{C}{/include/net/route.h}中。

            这是ipv4路由缓存相关结构体，保护了该路由缓存查找的匹配条件，即\mintinline{C}{struct flowi}类型的变量、目的ip、源ip、下一跳网关地址、路由类型等。当然了，还有最重要的，保护了一个协议无关的\mintinline{C}{dst_entry}变量，能够很好地实现\mintinline{C}{dst_entry}与rtable的转换，而\mintinline{C}{dst_entry}中又包含邻居项相关的信息，实现了路由缓存与邻居子系统的关联。

\begin{minted}[linenos]{C}
struct rtable {
    /*存储缓存路由项中独立于协议的信息*/
    struct dst_entry    dst;        

    int         rt_genid;
    /*表示路由表项的一些特性和标志*/
    unsigned int        rt_flags;
    __u16           rt_type;
    __u8            rt_is_input;
    __u8            rt_uses_gateway;

    int         rt_iif;

    /* Info on neighbour */
    __be32          rt_gateway;

    /* Miscellaneous cached information */
    u32         rt_pmtu;

    u32         rt_table_id;

    struct list_head    rt_uncached;
    struct uncached_list    *rt_uncached_list;
};
\end{minted}

        \subsection{flowi}

            该数据结构位于\mintinline{C}{/include/net/flow.h}中，它是与路由查找相关的数据结构。
\begin{minted}[linenos]{C}
struct flowi {
    union {
        struct flowi_common __fl_common;
        struct flowi4       ip4;
        struct flowi6       ip6;
        struct flowidn      dn;
    } u;
#define flowi_oif   u.__fl_common.flowic_oif
#define flowi_iif   u.__fl_common.flowic_iif
#define flowi_mark  u.__fl_common.flowic_mark
#define flowi_tos   u.__fl_common.flowic_tos
#define flowi_scope u.__fl_common.flowic_scope
#define flowi_proto u.__fl_common.flowic_proto
#define flowi_flags u.__fl_common.flowic_flags
#define flowi_secid u.__fl_common.flowic_secid
#define flowi_tun_key   u.__fl_common.flowic_tun_key
} __attribute__((__aligned__(BITS_PER_LONG/8)));
\end{minted}
%----------------------------------------------------------------------------------------
%                   Structre about TCP
%----------------------------------------------------------------------------------------
    \section{TCP层相关数据结构}
        \subsection{tcphdr}
            该数据结构位于/include/uapi/linux/tcp.h中。这一结构正是TCP首部在网络中
的样貌。
\begin{minted}[linenos]{C}
    struct tcphdr {
        __be16  source;
        __be16  dest;
        __be32  seq;
        __be32  ack_seq;
    #if defined(__LITTLE_ENDIAN_BITFIELD)
        __u16   res1:4,
            doff:4,
            fin:1,
            syn:1,
            rst:1,
            psh:1,
            ack:1,
            urg:1,
            ece:1,
            cwr:1;
    #elif defined(__BIG_ENDIAN_BITFIELD)
        __u16   doff:4,
            res1:4,
            cwr:1,
            ece:1,
            urg:1,
            ack:1,
            psh:1,
            rst:1,
            syn:1,
            fin:1;
    #else
    #error  "Adjust your <asm/byteorder.h> defines"
    #endif  
        __be16  window;
        __sum16 check;
        __be16  urg_ptr;
    };
\end{minted}

        \subsection{\mintinline{C}{tcp_options_received}}

        该结构位于\mintinline{C}{/include/linux/tcp.h}中，其主要表述TCP头部的选项字段。

\begin{minted}[linenos]{C}
struct tcp_options_received {
/*  PAWS/RTTM data  */
    long    ts_recent_stamp;  /* Time we stored ts_recent (for aging)        
                                记录从接收到的段中取出时间戳设置到ts_recent的时间
                                用于检测ts_recent的有效性：如果自从该事件之后已经
                                经过了超过24天的时间，则认为ts_recent已无效。
                              */
    u32 ts_recent;            /* Time stamp to echo next                     
                                下一个待发送的TCP段中的时间戳回显值。当一个含有最后
                                发送ACK中确认序号的段到达时，该段中的时间戳被保存在
                                ts_recent中。而下一个待发送的TCP段的时间戳值是由
                                SKB中TCP控制块的成员when填入的，when字段值是由协议
                                栈取系统时间变量jiffies的低32位。
                              */
    u32 rcv_tsval;            /* Time stamp value                            
                                保存最近一次接收到对端的TCP段的时间戳选项中的时间戳值。
                              */
    u32 rcv_tsecr;            /* Time stamp echo reply                       
                                保存最近一次接收到对端的TCP段的时间戳选项中的时间戳
                                回显应答。
                              */
    u16     saw_tstamp : 1,   /* Saw TIMESTAMP on last packet                
                                标识最近一次接收到的TCP段是否存在TCP时间戳选项，1为有，
                                0为无。
                              */
        tstamp_ok : 1,        /* TIMESTAMP seen on SYN packet                
                                标识TCP连接是否启动时间戳选项。
                              */
        dsack : 1,            /* D-SACK is scheduled                         */
        wscale_ok : 1,       /* Wscale seen on SYN packet                   
                                标志接收方是否支持窗口扩大因子，只出现在SYN段中。   
                             */
        sack_ok : 4,            /* SACK seen on SYN packet                     
                                    标记是否对方提供SACK服务
                                */
        snd_wscale : 4,       /* Window scaling received from sender         */
        rcv_wscale : 4;       /* Window scaling to send to receiver          */
    u8  num_sacks;            /* Number of SACK blocks                       */
    u16 user_mss;             /* mss requested by user in ioctl              */
    u16 mss_clamp;            /* Maximal mss, negotiated at connection setup */
};
\end{minted} 

		\subsection{\mintinline{C}{tcp_sacktag_state}}
\begin{minted}[linenos]{C}
/*
Location
	
	net/ipv4/tcp_input.c
*/
struct tcp_sacktag_state {
	int	reord;
	int	fack_count;
	/* Timestamps for earliest and latest never-retransmitted segment
	 * that was SACKed. RTO needs the earliest RTT to stay conservative,
	 * but congestion control should still get an accurate delay signal.
	 */
	struct skb_mstamp first_sackt;
	struct skb_mstamp last_sackt;
	int	flag;
};
\end{minted}           
        \subsection{\mintinline{C}{tcp_sock}}

            该数据结构位于\mintinline{C}{/include/linux/tcp.h}中。

            该数据结构时TCP协议的控制块，它在\mintinline{C}{inet_connection_sock}结构的基础上扩展了\textbf{滑动窗口协议}、\textbf{拥塞控制算法}等一些TCP的专有属性。
            
\begin{minted}[linenos]{C}
struct tcp_sock {
    /* inet_connection_sock has to be the first member of tcp_sock */
    struct inet_connection_sock inet_conn;
    u16 tcp_header_len; /* 需要发送的TCP头部的字节数      */
    u16 gso_segs;   /* Max number of segs per GSO packet    */

/*
 *  Header prediction flags
 *  0x5?10 << 16 + snd_wnd in net byte order
    首部预测标识。
*/
    __be32  pred_flags; 

/*
 *  RFC793 variables by their proper names. This means you can
 *  read the code and the spec side by side (and laugh ...)
 *  See RFC793 and RFC1122. The RFC writes these in capitals.
 */
    u64 bytes_received; /* RFC4898 tcpEStatsAppHCThruOctetsReceived
                 * sum(delta(rcv_nxt)), or how many bytes
                 * were acked.
                 */
    u32 segs_in;    /* RFC4898 tcpEStatsPerfSegsIn
                    * total number of segments in.
                    */
    u32 rcv_nxt;    /* 下一个待接收的字节号     */
    u32 copied_seq; /* Head of yet unread data      
						尚未读取数据的头部					
					*/
    u32 rcv_wup;    /* rcv_nxt on last window update sent   
						意思就是在上一个窗口更新的时候，所接收到的确认号
						也就是上一个窗口更新之后，将要发送的第一个字节的
						序列号。
					*/
    u32 snd_nxt;    /* 下一个待发送的序列        */
    u32 segs_out;   /* RFC4898 tcpEStatsPerfSegsOut
                 * The total number of segments sent.
                 */
    u64 bytes_acked;    /* RFC4898 tcpEStatsAppHCThruOctetsAcked
                 * sum(delta(snd_una)), or how many bytes
                 * were acked.
                 */
    struct u64_stats_sync syncp; /* protects 64bit vars (cf tcp_get_info()) */

    u32 snd_una;    /* 待ACK的第一个字节的序号    */
    u32 snd_sml;    /* Last byte of the most recently transmitted small packet */
    u32 rcv_tstamp; /* timestamp of last received ACK (for keepalives) */
    u32 lsndtime;   /* timestamp of last sent data packet (for restart window) */
    u32 last_oow_ack_time;  /* timestamp of last out-of-window ACK */

    u32 tsoffset;   /* timestamp offset */

    struct list_head tsq_node; /* anchor in tsq_tasklet.head list */
    unsigned long   tsq_flags;

    /* Data for direct copy to user */
    struct {
        struct sk_buff_head prequeue;
        struct task_struct  *task;
        struct msghdr       *msg;
        int         memory;
        int         len;
    } ucopy;

    u32 snd_wl1;    /* Sequence for window update       */
    u32 snd_wnd;    /* 发送窗口  */
    u32 max_window; /* Maximal window ever seen from peer   */
    u32 mss_cache;  /* Cached effective mss, not including SACKS */

    u32 window_clamp;   /* Maximal window to advertise     
                            滑动窗口最大值                     
                         */
    u32 rcv_ssthresh;   /* Current window clamp         */

    /* Information of the most recently (s)acked skb */
    struct tcp_rack {
        struct skb_mstamp mstamp; /* (Re)sent time of the skb */
        u8 advanced; /* mstamp advanced since last lost marking */
        u8 reord;    /* reordering detected */
    } rack;
    u16 advmss;     /* Advertised MSS           
                        本端能接收的MSS上限，在建立时用来通告对方。                 
                    */
    u8  unused;
    u8  nonagle     : 4,/* Disable Nagle algorithm?             */
        thin_lto    : 1,/* Use linear timeouts for thin streams */
        thin_dupack : 1,/* Fast retransmit on first dupack      */
        repair      : 1,
        frto        : 1;/* F-RTO (RFC5682) activated in CA_Loss */
    u8  repair_queue;
    u8  do_early_retrans:1,/* Enable RFC5827 early-retransmit  */
        syn_data:1, /* SYN includes data */
        syn_fastopen:1, /* SYN includes Fast Open option */
        syn_fastopen_exp:1,/* SYN includes Fast Open exp. option */
        syn_data_acked:1,/* data in SYN is acked by SYN-ACK */
        save_syn:1, /* Save headers of SYN packet */
        is_cwnd_limited:1;/* forward progress limited by snd_cwnd? */
    u32 tlp_high_seq;   /* snd_nxt at the time of TLP retransmit. */

/* RTT measurement */
    u32 srtt_us;    /* smoothed round trip time << 3 in usecs */
    u32 mdev_us;    /* medium deviation         */
    u32 mdev_max_us;    /* maximal mdev for the last rtt period */
    u32 rttvar_us;  /* smoothed mdev_max            */
    u32 rtt_seq;    /* sequence number to update rttvar */
    struct rtt_meas {
        u32 rtt, ts;    /* RTT in usec and sampling time in jiffies. */
    } rtt_min[3];

    u32 packets_out;    /* Packets which are "in flight"    
                            发送方发送出去但是还未得到确认的TCP段的数目
                            packets_out=SND.NXT-SND.UNA             
                        */
    u32 retrans_out;    /* Retransmitted packets out       
                            重传并且还未得到确认的TCP段的数目
                         */
    u32 max_packets_out;  /* max packets_out in last window */
    u32 max_packets_seq;  /* right edge of max_packets_out flight */

    u16 urg_data;   /* Saved octet of OOB data and control flags */
    u8  ecn_flags;  /* ECN status bits.         */
    u8  keepalive_probes; /* num of allowed keep alive probes   */
    u32 reordering; 	/* Packet reordering metric.        */
    u32 snd_up;     	/* Urgent pointer       */

/*
 *      Options received (usually on last packet, some only on SYN packets).
 */
    struct tcp_options_received rx_opt;

/*
 *  Slow start and congestion control (see also Nagle, and Karn & Partridge)
 */
    u32 snd_ssthresh;   /* Slow start size threshold        */
    u32 snd_cwnd;   	/* Sending congestion window        
							发送的拥塞窗口
						*/
    u32 snd_cwnd_cnt;   /* Linear increase counter      
                            自从上次调整拥塞窗口到目前为止接收到的总ACK段数。
                            如果该字段为零，则说明已经调整了拥塞窗口，且到目前
                            为止还没有接收到ACK段。调整拥塞窗口之后，每接收到
                            一个ACK，ACK段就会使snd_cwnd_cnt加1。
                        */
    u32 snd_cwnd_clamp; /* Do not allow snd_cwnd to grow above this */
    u32 snd_cwnd_used;
    u32 snd_cwnd_stamp; /*记录最近一次检验拥塞窗口的时间
                            在拥塞期间，接收到ACK后会进行
                            拥塞窗口的检验。而在非拥塞期间，为了防止由于应用
                            程序限制而造成拥塞窗口失效，因此在成功发送段后，
                            如果有必要也会检验拥塞窗口。
                        */
    u32 prior_cwnd; 	/* Congestion window at start of Recovery. 
							在进入Recovery状态时的拥塞窗口
						*/
    u32 prr_delivered;  /* Number of newly delivered packets to
                 		 * receiver in Recovery. 
							在恢复阶段给接收者新发送包的数量
						*/
    u32 prr_out;    	/* Total number of pkts sent during Recovery. 
							在恢复阶段一共发送的包的数量
						*/

    u32 rcv_wnd;    /* Current receiver window      */
    u32 write_seq;  /* Tail(+1) of data held in tcp send buffer 
						已加入发送队列中的最后一个字节序号。
					*/
    u32 notsent_lowat;  /* TCP_NOTSENT_LOWAT */
    u32 pushed_seq; /* Last pushed seq, required to talk to windows */
    u32 lost_out;   /* Lost packets         
                        丢失的数据报
                    */
    u32 sacked_out; /* SACK'd packets           
                        启用SACK时，通过SACK的TCP选项标识已接收到的段的数量。
                        不启用SACK时，标识接收到的重复确认的次数，该值在接收到确认新数据段时被清除。
                    */
    u32 fackets_out;    /* FACK'd packets           
                            记录SND.UNA与(SACK选项中目前接收方收到的段中最高序号段)之间的段数。FACK算法
                            用SACK选项来计算丢失在网络中上的段数
                            lost_out=fackets_out-sacked_out
                            left_out=fackets_out
                            找时间画一张图.???? remain ro do.
                        */

    /* from STCP, retrans queue hinting */
    struct sk_buff* lost_skb_hint;
    struct sk_buff *retransmit_skb_hint;

    /* OOO segments go in this list. Note that socket lock must be held,
     * as we do not use sk_buff_head lock.
     */
    struct sk_buff_head out_of_order_queue;

    /* SACKs data, these 2 need to be together (see tcp_options_write) */
    struct tcp_sack_block duplicate_sack[1]; /* D-SACK block */
    struct tcp_sack_block selective_acks[4]; /* The SACKS themselves*/

    struct tcp_sack_block recv_sack_cache[4];

    struct sk_buff *highest_sack;   /* skb just after the highest
                     * skb with SACKed bit set
                     * (validity guaranteed only if
                     * sacked_out > 0)
                     */

    int     lost_cnt_hint;
    u32     retransmit_high;    /* L-bits may be on up to this seqno */

    u32 prior_ssthresh; /* ssthresh saved at recovery start */
    u32 high_seq;   /* snd_nxt at onset of congestion   
                        开始拥塞的时候下一个要发送的序号字节                    
                    */

    u32 retrans_stamp;  /* Timestamp of the last retransmit,
                        * also used in SYN-SENT to remember stamp of
                        * the first SYN. 
                        */
    u32 undo_marker;    /* snd_una upon a new recovery episode. 
                            在使用F-RTO算法进行发送超时处理，或进入Recovery进行重传，
                            或进入Loss开始慢启动时，记录当时SND.UNA,标记重传起始点。
                            它是检测是否可以进行拥塞控制撤销的条件之一，一般在完成
                            拥塞撤销操作或进入拥塞控制Loss状态后会清零。
                        */
    int undo_retrans;   /* number of undoable retransmissions. 
                            在恢复拥塞控制之前可进行撤销的重传段数。在进入FTRO算法或
                            拥塞状态Loss时，清零，在重传时计数，是检测是否可以进行拥塞
                            撤销的条件之一。
                        */
    u32 total_retrans;  /* Total retransmits for entire connection */

    u32 urg_seq;        /* Seq of received urgent pointer */
    unsigned int        keepalive_time;   /* time before keep alive takes place */
    unsigned int        keepalive_intvl;  /* time interval between keep alive probes */

    int         linger2;

/* Receiver side RTT estimation */
    struct {
        u32 rtt;
        u32 seq;
        u32 time;
    } rcv_rtt_est;

/* Receiver queue space */
    struct {
        int space;
        u32 seq;
        u32 time;
    } rcvq_space;

/* TCP-specific MTU probe information. */
    struct {
        u32       probe_seq_start;
        u32       probe_seq_end;
    } mtu_probe;
    u32 mtu_info; /* We received an ICMP_FRAG_NEEDED / ICMPV6_PKT_TOOBIG
               * while socket was owned by user.
               */

#ifdef CONFIG_TCP_MD5SIG
/* TCP AF-Specific parts; only used by MD5 Signature support so far */
    const struct tcp_sock_af_ops    *af_specific;

/* TCP MD5 Signature Option information */
    struct tcp_md5sig_info  __rcu *md5sig_info;
#endif

    /* 与TCP Fast Open相关的信息 */
    struct tcp_fastopen_request *fastopen_req;
    /* fastopen_rsk points to request_sock that resulted in this big
     * socket. Used to retransmit SYNACKs etc.
     */
    struct request_sock *fastopen_rsk;
    u32 *saved_syn;
};
\end{minted}
\subsection{\mintinline{c}{tcp_fastopen_cookie}}
这里，len和val分别对应于\ref{subsubsec:fast-open-option}中描述的选项格式中的
len和cookie。如果len为0，则代表需要请求一个Cookie。
\begin{minted}[linenos]{c}
/* Location: include/linux/tcp.h
 *
 * TCP Fast Open Cookie as stored in memory 
 */
struct tcp_fastopen_cookie {
        s8      len;
        u8      val[TCP_FASTOPEN_COOKIE_MAX];
        bool    exp;    /* In RFC6994 experimental option format */
};
\end{minted}
\subsection{\mintinline{c}{tcp_fastopen_request}}
该结构体用于记录在fast open过程中发送数据的请求。
\begin{minted}[linenos]{c}
struct tcp_fastopen_request {
        /* Fast Open cookie. */
        struct tcp_fastopen_cookie      cookie;
        struct msghdr                   *data;  /* 在fast open状态下想发送的数据 */
        size_t                          size;
        int                             copied; /* queued in tcp_connect() */
};
\end{minted}
        \subsection{\mintinline{C}{tcp_request_sock}}
\begin{minted}[linenos]{C}
struct tcp_request_sock {
    struct inet_request_sock    req;
    const struct tcp_request_sock_ops *af_specific;
    struct skb_mstamp       snt_synack;             /* first SYNACK sent time */
    bool                tfo_listener;
    u32             txhash;
    u32             rcv_isn;
    u32             snt_isn;
    u32             last_oow_ack_time;              /* last SYNACK */
    u32             rcv_nxt;                        /* the ack # by SYNACK. For
                                                        * FastOpen it's the seq#
                                                        * after data-in-SYN.
                                                    */
};
\end{minted}
        \subsection{\mintinline{C}{tcp_skb_cb}}
            \label{sec:tcp_skb_cb}

            在\ref{sec:sk_buff}中，我们分析过\mintinline{c}{cb}。该结构是TCP层在SKB区的
            私有信息控制块。对这个私有信息控制块的赋值一般在本层接收到段或发送段之前进行。
            在这一节中，我们将看到TCP层具体是如何使用这个控制缓冲区(Control Buffer)的。

            \subsubsection{TCP\_SKB\_CB}
                \label{subsec:tcp_skb_cb}

            在TCP层，用该宏访问给定的\mintinline{c}{sk_buff}的控制缓冲区的变量。在后续的章节中，
            可以在很多函数中看到它的身影。该宏的定义如下：

\begin{minted}[linenos]{c}
#define TCP_SKB_CB(__skb)       ((struct tcp_skb_cb *)&((__skb)->cb[0]))
\end{minted}

            可以看到，该宏实际上是将\mintinline{c}{cb}的指针强制转型成\mintinline{c}{tcp_skb_cb}
            结构体的指针。也就是说，TCP对于控制缓冲区的使用，可以从\mintinline{c}{tcp_skb_cb}
            的定义分析出来。

\subsubsection{tcp\_skb\_cb结构体}
\label{subsec:tcp_skb_sb_structure}
\mintinline{c}{tcp_skb_cb}结构体用于将每个TCP包中的控制信息传递给发送封包的代码。
该结构体的定义如下：
\begin{minted}[linenos]{c}
struct tcp_skb_cb {
        __u32           seq;            /* 起始序号     */
        __u32           end_seq;        /* SEQ + FIN + SYN + datalen    */
        union {
                /* Note : tcp_tw_isn is used in input path only
                 *        (isn chosen by tcp_timewait_state_process())
                 *
                 *        tcp_gso_segs/size are used in write queue only,
                 *        cf tcp_skb_pcount()/tcp_skb_mss()
                 */
                __u32           tcp_tw_isn;
                struct {
                        u16     tcp_gso_segs;
                        u16     tcp_gso_size;
                };
        };
        __u8            tcp_flags;      /* TCP头部的标志位 */

        __u8            sacked;         /* SACK/FACK标志位           .   */
\end{minted}
紧接着，定义了一些宏作为标志
\begin{minted}[linenos]{c}
#define TCPCB_SACKED_ACKED      0x01    /* SKB 被确认了                  */
#define TCPCB_SACKED_RETRANS    0x02    /* SKB 被重传了                  */
#define TCPCB_LOST              0x04    /* SKB 已丢失                    */
#define TCPCB_TAGBITS           0x07    /* 标志位掩码                    */
#define TCPCB_REPAIRED          0x10    /* SKB 被修复了 (no skb_mstamp)  */
#define TCPCB_EVER_RETRANS      0x80    /* SKB曾经被重传过                */
#define TCPCB_RETRANS           (TCPCB_SACKED_RETRANS|TCPCB_EVER_RETRANS| \
                                TCPCB_REPAIRED)
\end{minted}
接下来又继续定义TCP相关的位。
\begin{minted}[linenos]{c}
        __u8            ip_dsfield;     /* IPv4 tos or IPv6 dsfield     */
        /* 1 byte hole */
        __u32           ack_seq;        /* ACK的序号                     */
        union {
                struct inet_skb_parm    h4;
#if IS_ENABLED(CONFIG_IPV6)
                struct inet6_skb_parm   h6;
#endif
        } header;       /* For incoming frames          */
};
\end{minted}

\subsubsection{\mintinline{c}{tcp_out_options}}
\mintinline{c}{tcp_out_options}用于存放发送TCP包时，TCP包所含的选项。
\begin{minted}[linenos]{c}
/* Location: net/ipv4/tcp_output.c */
#define OPTION_SACK_ADVERTISE   (1 << 0)
#define OPTION_TS               (1 << 1)
#define OPTION_MD5              (1 << 2)
#define OPTION_WSCALE           (1 << 3)
#define OPTION_FAST_OPEN_COOKIE (1 << 8)

struct tcp_out_options {
        u16 options;            /* OPTION_*的位域 */
        u16 mss;                /* 如果为0，则表示关闭该选项 */
        u8 ws;                  /* 窗口放大， 0表示关闭该选项 */
        u8 num_sack_blocks;     /* number of SACK blocks to include */
        u8 hash_size;           /* bytes in hash_location */
        __u8 *hash_location;    /* temporary pointer, overloaded */
        __u32 tsval, tsecr;     /* need to include OPTION_TS */
        struct tcp_fastopen_cookie *fastopen_cookie;    /* Fast open cookie */
};
\end{minted}
